:le: &#8804;

== Ziccif Extension for Instruction-Fetch Atomicity, Version 1.0

NOTE: This extension was ratified alongside the RVA20U64 profile.
This chapter supplies an operational definition for the extension
and adds expository material.

If the Ziccif extension is implemented, main memory regions with both the
cacheability and coherence PMAs must support instruction fetch, and any
instruction fetches of naturally aligned power-of-2 sizes of at most
`min(ILEN,XLEN)` bits are atomic.

An implementation with the Ziccif extension fetches instructions in a manner
equivalent to the following state machine.

. Let `M` be `min(ILEN,XLEN)/8`, rounded up to the next power of 2.
Let `N` be the `pc` modulo `M`.
Atomically fetch `M` - `N` bytes from memory at address `pc`.
Let `T` be the running total of bytes fetched, initially `M` - `N`.

. If the `T` bytes fetched begin with a complete instruction of length `L` {le}
`T`, then execute that instruction, discard the remaining `T` - `L` bytes
fetched, and go back to step 1, using the updated `pc`.

. Otherwise, atomically fetch `M` bytes from memory at address `pc` + `T`,
increment `T` by `M`, and go back to step 2.

[NOTE]
====
The instruction-fetch atomicity rule supports concurrent code modification.
If a hart modifies instruction memory that it, or other, harts might
execute without first having executed a FENCE.I instruction, it should
adhere to the following rules:

- Modification stores must be single-copy atomic, hence must be naturally
aligned.

- The modified instruction must not span an `M`-byte boundary,
unless it is replaced with a shorter unconditional control transfer
(e.g. `c.ebreak` or `c.j`) that does not itself span an `M`-byte
boundary.

- Modification stores must alter a complete instruction or complete
instructions that do not collectively span an `M`-byte boundary,
modulo the exception above that the first part of an instruction may be
replaced with an unconditional control transfer instruction.

- Modifications may not combine smaller instructions into a larger
instruction but may convert a larger instruction to some number of
smaller instructions.

- Modified instruction memory must have the coherence PMA.

Other well-defined code-modification strategies exist, but these rules provide
a safe harbor.

Note that the software modifying the code need not know the value of `M`.
Because ILEN must be at least the width of the instruction being modified,
a lower bound on `M` can be inferred from the instruction's width and XLEN.
====

Memory protection is applied only to bytes that are not discarded by this
algorithm.

[NOTE]
====
For example, if `M`=8, `N`=0, and the PMP granularity is 4 bytes, then
it is valid to fetch a 4-byte instruction at `pc`, even if fetching from
`pc` + 4 would have been disallowed by PMP.

For simplicity, implementations are likely to choose a PMP granularity no
smaller than `M`.
====

== Ziccid Extension for Instruction/Data Coherence and Consistency, Version 0.2

The Ziccid extension mandates more stringent requirements for consistency
between instruction fetches and other memory accesses than those imposed by
the base ISA.
As formalized in the next section, Ziccid guarantees that a hart's instruction
fetches appear to occur in program order with respect to each other, and that
stores eventually become visible to all harts' instruction fetches.

[NOTE]
====
The primary intent of the Ziccid extension is to accelerate JIT
compilation in multiprocessor systems.

In straightforward implementations, maintaining coherence between instruction
caches and the data-memory system suffices to satisfy this extension's
strictures.
The Ziccid extension can be viewed as a means to codify the concept of
instruction-cache coherence.

The in-order fetch property, expected by some JIT compilers, is also
naturally provided by most straightforward microarchitectures.
An example of a technique that might violate this property, however, is an
instruction buffer that is populated out of program order, e.g. while fetching
down the predicted path following an instruction-cache miss.
Example solutions include only buffering instructions in program order, or
keeping the buffer coherent by making the coherent instruction cache inclusive
of the buffer.
====

[NOTE]
====
Under Ziccid, stores _eventually_ become visible to instruction fetches, even
without executing a FENCE.I instruction.
As a consequence of this requirement, the consumer thread in the following
litmus test is guaranteed to terminate:

```
Producer:                                       Consumer:

la t0, patch_me                               patch_me:
li t1, 0x4585                                   c.li a1, 0
sh t1, (t0)   # patch_me := c.li a1, 1          beqz a1, patch_me
```

As is the case without the Ziccid extension, a store from the current hart can
be made visible to the hart's instruction fetches in program order by
executing a FENCE.I instruction, or to a remote hart's instruction fetches by
executing a FENCE then requesting (e.g. via IPI) that the remote hart execute
a FENCE.I.
====

The Ziccid extension depends on the Ziccif extension.

NOTE: Although instruction/data consistency and instruction-fetch atomicity
are conceptually independent properties, the former is much more useful in
conjunction with the latter.

=== Operational Model of the Ziccid Extension

An implementation with the Ziccid extension behaves in a manner consistent
with the following operational model.

Harts have two operational stages: instruction fetch and execution.
Each hart has an instruction cache and an instruction buffer of bounded
capacity.
Instructions are fetched in program order from the instruction cache, then
inserted into the instruction buffer in program order.
If an instruction is not present in the instruction cache, the instruction is
read from memory and cached.
The instruction cache may also be populated by prefetching from arbitrary
memory addresses.

For each instruction byte read from memory, memory supplies the value written
by the most recent store that precedes the fetch in global memory order or
program order.

NOTE: This property is a restatement of RVWMO's Load Value Axiom, as applied
to instruction-cache refills.

After some amount of time, instructions are dequeued in program order from the
instruction buffer and executed.

NOTE: Therefore, absent the execution of a FENCE.I instruction,
stores do not immediately become visible to subsequent instruction fetches,
though they do eventually become visible to subsequent instruction fetches.

Instructions are executed in program order, but explicit memory accesses to
which instructions give rise may be reordered in any manner consistent with
RVWMO.

NOTE: For example, executing a `fence w,w` instruction between two store
instructions suffices to guarantee that the second store will not become
visible to any instruction fetch before the first store.

Writes to memory regions with both the cacheability and coherence PMAs, as
part of the execution phase, remove the local hart's instruction-cache entries
corresponding to the same address.

NOTE: This property does not imply that the fetch of an instruction immediately
following a store will observe the store, as the subsequent instruction might
already have been fetched and written into the instruction buffer.

Writes to memory regions with both the cacheability and coherence PMAs, as
part of becoming globally visible, remove all harts' instruction-cache entries
corresponding to the same address.

The FENCE.I instruction flushes the instruction buffer.

The FENCE.I instruction additionally flushes all of the local hart's
instruction-cache entries corresponding memory regions that do _not_ have both
the cacheability and coherence PMAs.
