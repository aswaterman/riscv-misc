:le: &#8804;
:ge: &#8805;

== Ziccif Extension for Instruction-Fetch Atomicity, Version 1.0

NOTE: This extension was ratified alongside the RVA20U64 profile.
This chapter supplies an operational definition for the extension
and adds expository material.

If the Ziccif extension is implemented, main memory regions with both the
cacheability and coherence PMAs must support instruction fetch, and any
instruction fetches of naturally aligned power-of-2 sizes of at most
`min(ILEN,XLEN)` bits are atomic.

An implementation with the Ziccif extension fetches instructions in a manner
equivalent to the following state machine.

. Let `M` be the smallest power of 2 such that `M` {ge} `min(ILEN,XLEN)/8`.
Let `N` be the `pc` modulo `M`.
Atomically fetch `M` - `N` bytes from memory at address `pc`.
Let `T` be the running total of bytes fetched, initially `M` - `N`.

. If the `T` bytes fetched begin with a complete instruction of length `L` {le}
`T`, then execute that instruction, discard the remaining `T` - `L` bytes
fetched, and go back to step 1, using the updated `pc`.
Otherwise, atomically fetch `M` bytes from memory at address `pc` + `T`,
increment `T` by `M`, and repeat step 2.

[NOTE]
====
The instruction-fetch atomicity rule supports concurrent code modification.
When a hart modifies instruction memory and either it or another hart executes
the modified instructions without first having executing a FENCE.I, the
modifying hart should adhere to the following rules to ensure predictable
behavior:

- Modification stores must be single-copy atomic, hence must be naturally
aligned.

- The modified instruction must not span an aligned `M`-byte boundary,
unless it is replaced with a shorter unconditional control transfer
(e.g., `c.ebreak` or `c.j`) that does not itself span an `M`-byte
boundary.

- Modification stores must alter a complete instruction or complete
instructions that do not collectively span an `M`-byte boundary,
modulo the exception above that the first part of an instruction may be
replaced with an unconditional control transfer instruction.

- Modifications must not combine smaller instructions into a larger
instruction but may convert a larger instruction to some number of
smaller instructions.

- Modified instruction memory must have the coherence PMA.

Other well-defined code-modification strategies exist, but these rules provide
a safe harbor.

Note that the software modifying the code need not know the value of `M`.
Because ILEN must be at least the width of the instruction being modified,
a lower bound on `M` can be inferred from the instruction's width and XLEN.
====

Memory protection and executability PMAs are applied only to bytes that are
not discarded by this algorithm.

[NOTE]
====
For example, if `M`=8, `N`=0, and the PMP granularity is 4 bytes, then
it is valid to fetch a 4-byte instruction at `pc`, even if fetching from
`pc` + 4 would have been disallowed by PMP.

For simplicity, implementations are likely to choose a PMP granularity no
smaller than `M`.
====

== Ziccid Extension for Instruction/Data Coherence and Consistency, Version 0.2

The Ziccid extension mandates more stringent requirements for consistency
between instruction fetches and other memory accesses than those imposed by
the base ISA.
As described in detail in the next section, Ziccid guarantees that a hart's
instruction fetches appear to occur in program order with respect to each
other, and that stores eventually become visible to all harts' instruction
fetches.

[NOTE]
====
The primary intent of the Ziccid extension is to accelerate JIT
compilation in multiprocessor systems.

In straightforward implementations, maintaining coherence between instruction
caches and the data-memory system suffices to satisfy this extension's
eventuality property.
The Ziccid extension can be viewed as a means to codify the concept of
instruction-cache coherence.

The in-order fetch property, expected by some JIT compilers, is also
provided naturally by most straightforward microarchitectures.
An example of a technique that might violate this property, however, is an
instruction buffer that is populated out of program order, e.g., while fetching
down the predicted path following an instruction-cache miss.
Example solutions include buffering instructions only in program order, or
keeping the buffer coherent by making the coherent instruction cache inclusive
of the buffer.
====

[NOTE]
====
Under Ziccid, stores _eventually_ become visible to instruction fetches, even
without executing a FENCE.I instruction.
As a consequence of this requirement, the consumer thread in the following
litmus test is guaranteed to terminate:

```
Producer:                                       Consumer:

la t0, patch_me                               patch_me:
li t1, 0x4585                                   c.li a1, 0
sh t1, (t0)   # patch_me := c.li a1, 1          beqz a1, patch_me
```

As is the case without the Ziccid extension, software can make a store from
the current hart visible to the hart's instruction fetches immediately by
executing a FENCE.I instruction.
Software can make a store from the current hart visible to another hart's
instruction fetches by executing a FENCE W,O instruction, then sending an
interprocessor interrupt to the remote hart, requesting that it execute
a FENCE.I instruction.
Alternatively, the current hart can execute a FENCE W,W instruction, then
write a flag in memory; upon observing the flag write, the remote hart
executes a FENCE.I instruction.
In neither case is a data FENCE required on the remote hart.
====

The Ziccid extension depends on the Ziccif extension.

NOTE: Although instruction/data consistency and instruction-fetch atomicity
are conceptually independent properties, the former is much more useful in
conjunction with the latter.

=== Operational Model of the Ziccid Extension

An implementation with the Ziccid extension behaves in a manner consistent
with the following operational model.

Harts have two ordered operational stages: instruction fetch and execution.
Each hart has an instruction cache and an instruction buffer of bounded
capacity.
Instructions are fetched in program order from the instruction cache, then
inserted into the instruction buffer in program order.
If an instruction is not present in the instruction cache, the instruction is
read from memory, inserted into the cache, then inserted into the instruction
buffer in program order.

An instruction fetch is a memory read operation that appears in the global
memory order.
For each instruction byte fetched from memory into the instruction cache, memory
supplies the value written by the most recent store that precedes the read in
global memory order.

NOTE: This property is distinct from than the load-value axiom, in that fetches
do not observe the local hart's stores before other harts' fetches can observe them.

Instruction-cache entries may be removed at any time.
Instruction-cache entries corresponding to arbitrary memory addresses
may be inserted at any time.

NOTE: These properties permit prefetching and speculation.

After some amount of time, instructions are dequeued in program order from the
instruction buffer and executed.

NOTE: Therefore, absent the execution of a FENCE.I instruction,
stores do not necessarily become visibile immediately to subsequent instruction fetches,
though they do _eventually_ become visible to subsequent instruction fetches.

Instructions are executed in program order, but instructions' explicit memory
accesses may be reordered in any manner consistent with RVWMO.

NOTE: Executing a `fence w,w` instruction between two store instructions, for
example, suffices to guarantee that the second store will not become visible
to any instruction fetch before the first store does.

Stores to memory regions with both the cacheability and coherence PMAs
remove all harts' instruction-cache entries corresponding to the same
physical address, as part of becoming globally visible.

The FENCE.I instruction performs the following operations sequentially:

- All of the hart's older explicit memory accesses become globally visible.
- All of the hart's instruction-cache entries corresponding to memory regions that
  do _not_ have both the cacheability and coherence PMAs are removed.
- The instruction buffer is flushed.

[NOTE]
====
The FENCE.I instruction in Ziccid is specified such that software written for
non-Ziccid machines is compatible with Ziccid machines.

For cacheable and coherent memory regions, the combination of removing
instruction-cache entries upon global store visibility and flushing the
instruction buffer on FENCE.I suffices to implement FENCE.I's pre-Ziccid
semantics for those regions.

For non-cacheable and/or non-coherent memory regions, the combination of
removing all instruction-cache entries corresponding to those regions and
flushing the instruction buffer on FENCE.I suffices to implement FENCE.I's
pre-Ziccid semantics for those regions.
====
